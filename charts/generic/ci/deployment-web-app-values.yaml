# Example: AWS Web Application Deployment
# A typical web application on EKS with ALB ingress, autoscaling, and monitoring

nameOverride: "webapp"
fullnameOverride: ""

workload:
  type: deployment
  enabled: true
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1

image:
  repository: nginx
  tag: "1.25-alpine"
  pullPolicy: IfNotPresent

deployment:
  resources:
    limits:
      memory: "512Mi"
      cpu: "500m"
    requests:
      cpu: "100m"
      memory: "256Mi"

  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10

  readinessProbe:
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 5

service:
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: alb
  # controller is not specified, so it will use the default (alb)
  alb:
    annotations:
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip
      alb.ingress.kubernetes.io/healthcheck-path: /health
      alb.ingress.kubernetes.io/healthcheck-interval-seconds: "30"
      alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
      alb.ingress.kubernetes.io/success-codes: "200,404"
      alb.ingress.kubernetes.io/tags: Environment=production,Application=webapp
      alb.ingress.kubernetes.io/group.name: shared-alb
      alb.ingress.kubernetes.io/group.order: "10"
      # Using ACM certificate instead of cert-manager for ALB
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
      alb.ingress.kubernetes.io/ssl-redirect: "443"
  hosts:
    - host: webapp.example.com
      paths:
        - path: /
          pathType: Prefix
  # TLS is handled by ALB with ACM certificate
  tls: []

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

podDisruptionBudget:
  enabled: true
  minAvailable: 2

podMonitor:
  enabled: true
  interval: 30s
  path: /metrics

configMap:
  enabled: true
  data:
    APP_ENV: "production"
    LOG_LEVEL: "info"
    API_TIMEOUT: "30s"

secret:
  enabled: true
  stringData:
    API_KEY: "super-secret-key"
    DB_PASSWORD: "another-secret"

# Native sidecar for metrics collection
sidecarContainers:
  - name: metrics-exporter
    image: prom/node-exporter:latest
    ports:
      - name: metrics
        containerPort: 9100
    resources:
      limits:
        memory: "64Mi"
        cpu: "50m"
      requests:
        memory: "32Mi"
        cpu: "10m"

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - webapp
          topologyKey: kubernetes.io/hostname

# Service account with IRSA for AWS access
serviceAccount:
  enabled: true
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/webapp-service-role
  name: webapp-sa
