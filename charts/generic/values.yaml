# Default values for generic chart
# This is a YAML-formatted file with secure defaults

# Common labels and annotations applied to all resources
commonLabels: {}
commonAnnotations: {}

generic:
  # Values for templating - use these in other template expressions
  branchName: ""     # e.g., "feature-123", "main", "develop"
  environment: ""    # e.g., "dev", "staging", "production"

# Metadata
nameOverride: ""
fullnameOverride: ""
namespaceOverride: ""
podLabels: {}
podAnnotations: {}

# Image configuration
image:
  repository: registry.k8s.io/pause
  tag: "3.10"
  pullPolicy: IfNotPresent

imagePullSecrets: []
# - name: myregistrykey

# Main deployment configuration
deployment:
  enabled: true
  replicas: 1
  revisionHistoryLimit: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 25%
  progressDeadlineSeconds: 600
  # Container configuration
  command: []
  args: []
  env: []
  envFrom: []
  resources:
    limits:
      memory: "256Mi"
    requests:
      cpu: "100m"
      memory: "128Mi"
  securityContext: {}
  livenessProbe: {}
  readinessProbe: {}
  startupProbe: {}
  lifecycle: {}
  volumeMounts: []

# Extra deployments (key is deployment name suffix)
extraDeployments: {}
# worker:
#   replicas: 2
#   image:
#     repository: myapp
#     tag: worker-1.0.0
#   resources:
#     requests:
#       cpu: 200m
#       memory: 256Mi
#   env:
#     - name: WORKER_TYPE
#       value: background
#   # Override scheduling for this specific deployment
#   nodeSelector:
#     workload-type: batch
#   tolerations:
#     - key: batch-processing
#       operator: Equal
#       value: "true"
#       effect: NoSchedule
#   affinity:
#     nodeAffinity:
#       requiredDuringSchedulingIgnoredDuringExecution:
#         nodeSelectorTerms:
#           - matchExpressions:
#               - key: node.kubernetes.io/instance-type
#                 operator: In
#                 values:
#                   - m5.xlarge
#                   - m5.2xlarge

# Security contexts with secure defaults
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  fsGroupChangePolicy: OnRootMismatch
  seccompProfile:
    type: RuntimeDefault

# Default container security context (applied to all containers)
containerSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
    - ALL
  seccompProfile:
    type: RuntimeDefault
# To override for specific containers that need writable filesystem:
# deployment:
#   securityContext:
#     readOnlyRootFilesystem: false

# Security settings
security:
  podSecurityStandards:
    enforce: ""
    audit: ""
    warn: ""
  apparmor:
    enabled: false
    profile: runtime/default

# Pod Security Standards and Policy Enforcement
podSecurity:
  # Pod Security Standards (PSS) - Kubernetes native
  podSecurityStandards:
    enabled: false
    # Pod Security Standard levels: privileged, baseline, restricted
    enforce: ""  # restricted, baseline, privileged
    audit: ""    # restricted, baseline, privileged
    warn: ""     # restricted, baseline, privileged
    labels: {}
    annotations: {}
    # Namespace-level enforcement (creates namespace if not exists)
    namespaceEnforcement: false

# Multi-container configuration
containers: []
# - name: main
#   image: nginx:alpine
#   ports:
#   - name: http
#     containerPort: 80
#   env:
#   - name: MY_VAR
#     value: my-value
#   resources:
#     limits:
#       memory: "256Mi"
#     requests:
#       cpu: "100m"
#       memory: "128Mi"

initContainers: []
# - name: wait-for-db
#   image: busybox:1.35
#   command: ['sh', '-c']
#   args:
#     - |
#       echo "Waiting for database to be ready..."
#       until nc -z postgres-service 5432; do
#         echo "Database is unavailable - sleeping"
#         sleep 2
#       done
#       echo "Database is up - continuing"
#   resources:
#     requests:
#       cpu: 10m
#       memory: 16Mi
#     limits:
#       cpu: 50m
#       memory: 64Mi

# Implemented as init containers with restartPolicy: Always
sidecarContainers: []
# - name: metrics-exporter
#   image: prom/node-exporter:latest
#   ports:
#   - name: metrics
#     containerPort: 9100
#   args:
#   - --path.rootfs=/host
#   - --collector.filesystem.ignored-mount-points
#   - ^/(sys|proc|dev|host|etc|rootfs/var/lib/docker/containers|rootfs/var/lib/docker/overlay2|rootfs/run/docker/netns|rootfs/var/lib/docker/aufs)($$|/)
#   volumeMounts:
#   - name: proc
#     mountPath: /host/proc
#     readOnly: true
#   - name: sys
#     mountPath: /host/sys
#     readOnly: true
#   resources:
#     limits:
#       memory: "128Mi"
#     requests:
#       cpu: "50m"
#       memory: "64Mi"
#   # Native sidecar containers have these characteristics:
#   # - Start before main containers
#   # - Restart automatically (restartPolicy: Always)
#   # - Continue running alongside main containers
#   # - Share the same lifecycle as the pod

# Container ports
containerPorts: []
# - name: http
#   containerPort: 80
#   protocol: TCP

# Pod settings
hostNetwork: false
hostPID: false
hostIPC: false
hostname: ""
dnsPolicy: ""
dnsConfig: {}
priorityClassName: ""
priority: null
runtimeClassName: ""
schedulerName: ""
terminationGracePeriodSeconds: 30
activeDeadlineSeconds: null
restartPolicy: null

# Common environment variables
commonEnvVars: false  # Set to true to inject POD_NAME, POD_NAMESPACE, etc.
env: []
envFrom: []
# Extra environment sources to be added in addition to automatic envFrom
# This is useful when you want to keep the automatic envFrom behavior
# (for configMaps/secrets with envFrom: true) while adding additional sources
extraEnvFrom: []
# extraEnvFrom:
#   - secretRef:
#       name: my-external-secret
#   - configMapRef:
#       name: my-external-configmap
#       optional: true

# Scheduling
nodeSelector: {}
# nodeSelector:
#   kubernetes.io/arch: amd64
#   node.kubernetes.io/instance-type: m5.large
#   environment: production
#   team: backend

tolerations: []
# # Allow pods on nodes marked for GPU workloads
# - key: nvidia.com/gpu
#   operator: Exists
#   effect: NoSchedule
# # Allow pods on nodes being drained (for 5 minutes)
# - key: node.kubernetes.io/unschedulable
#   operator: Exists
#   effect: NoSchedule
#   tolerationSeconds: 300
# # Allow pods on spot instances
# - key: spot-instance
#   operator: Equal
#   value: "true"
#   effect: NoSchedule
# # Allow pods on dedicated nodes
# - key: dedicated
#   operator: Equal
#   value: backend
#   effect: NoSchedule

affinity: {}
# # Prefer to schedule pods on nodes in specific zones
# nodeAffinity:
#   preferredDuringSchedulingIgnoredDuringExecution:
#     - weight: 100
#       preference:
#         matchExpressions:
#           - key: topology.kubernetes.io/zone
#             operator: In
#             values:
#               - us-east-1a
#               - us-east-1b
#   # Require pods to run on nodes with SSD storage
#   requiredDuringSchedulingIgnoredDuringExecution:
#     nodeSelectorTerms:
#       - matchExpressions:
#           - key: storage-type
#             operator: In
#             values:
#               - ssd
#               - nvme
# # Prefer to co-locate with cache pods
# podAffinity:
#   preferredDuringSchedulingIgnoredDuringExecution:
#     - weight: 100
#       podAffinityTerm:
#         labelSelector:
#           matchExpressions:
#             - key: app.kubernetes.io/name
#               operator: In
#               values:
#                 - redis
#                 - memcached
#         topologyKey: kubernetes.io/hostname
# # Ensure pods are spread across nodes (anti-affinity)
# podAntiAffinity:
#   # Soft anti-affinity (preferred)
#   preferredDuringSchedulingIgnoredDuringExecution:
#     - weight: 100
#       podAffinityTerm:
#         labelSelector:
#           matchExpressions:
#             - key: app.kubernetes.io/name
#               operator: In
#               values:
#                 - myapp
#         topologyKey: kubernetes.io/hostname

# Default topology spread constraints for better pod distribution
# Note: These will be automatically configured with proper labelSelector in the template
topologySpreadConstraints:
  # Spread pods evenly across nodes
  - maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: ScheduleAnyway
  # Spread pods evenly across zones (if using multi-zone clusters)
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
# To disable default topology spread constraints, set to empty array:
# topologySpreadConstraints: []
# Custom topology spread constraints examples:
# topologySpreadConstraints:
#   # Strict node spreading - fail scheduling if constraint can't be met
#   - maxSkew: 1
#     topologyKey: kubernetes.io/hostname
#     whenUnsatisfiable: DoNotSchedule
#     # labelSelector is automatically added by the template if not specified
#   # Spread across zones with minimum 2 zones
#   - maxSkew: 1
#     topologyKey: topology.kubernetes.io/zone
#     whenUnsatisfiable: DoNotSchedule
#     minDomains: 2  # Requires at least 2 zones
#   # Custom label selector for specific component
#   - maxSkew: 1
#     topologyKey: kubernetes.io/hostname
#     whenUnsatisfiable: ScheduleAnyway
#     labelSelector:
#       matchLabels:
#         app.kubernetes.io/component: web
#       matchExpressions:
#         - key: tier
#           operator: In
#           values:
#             - frontend
#   # Advanced: Consider node affinity when spreading
#   - maxSkew: 2
#     topologyKey: rack
#     whenUnsatisfiable: ScheduleAnyway
#     nodeAffinityPolicy: Honor  # Consider nodeAffinity when calculating spread
#     nodeTaintsPolicy: Ignore   # Ignore taints when calculating spread

# Service configuration
service:
  enabled: true
  type: ClusterIP
  ports:
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
  annotations: {}
  labels: {}
  clusterIP: ""
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  externalTrafficPolicy: null
  sessionAffinity: null
  sessionAffinityConfig: {}
  publishNotReadyAddresses: false

# Extra services
extraServices: {}
# metrics:
#   enabled: true
#   type: ClusterIP
#   ports:
#   - name: metrics
#     port: 9090
#     targetPort: 9090
#   annotations:
#     prometheus.io/scrape: "true"
#     prometheus.io/port: "9090"
# headless:
#   enabled: true
#   type: ClusterIP
#   clusterIP: None
#   ports:
#   - name: grpc
#     port: 50051
#     targetPort: 50051

# Ingress configuration
ingress:
  enabled: false
  ingressClassName: "alb"
  labels: {}
  annotations: {}
  # Example ALB annotations for AWS Load Balancer Controller
  # alb.ingress.kubernetes.io/scheme: internet-facing
  # alb.ingress.kubernetes.io/target-type: ip
  # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:region:account-id:certificate/certificate-id
  # alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
  # alb.ingress.kubernetes.io/ssl-redirect: "443"
  # alb.ingress.kubernetes.io/backend-protocol: HTTP
  # alb.ingress.kubernetes.io/healthcheck-path: /health
  # alb.ingress.kubernetes.io/healthcheck-interval-seconds: "15"
  # alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
  # alb.ingress.kubernetes.io/success-codes: "200"
  # alb.ingress.kubernetes.io/tags: Environment=prod,Team=platform
  # alb.ingress.kubernetes.io/group.name: my-alb-group
  # alb.ingress.kubernetes.io/group.order: "10"

  # Default backend
  defaultBackend: {}
  # service:
  #   name: default-backend
  #   port:
  #     number: 80

  hosts: []
  # - host: "{{ .Values.generic.branchName }}.example.com"  # Template example
  #   paths:
  #   - path: /
  #     pathType: ImplementationSpecific
  #     backend:
  #       service:
  #         name: ""  # defaults to release fullname
  #         port:
  #           number: 80
  #           # or
  #           # name: http

# Extra ingresses
extraIngresses: {}
# admin:
#   enabled: true
#   ingressClassName: nginx
#   annotations: {}
#   hosts:
#   - host: admin.example.com
#     paths:
#     - path: /
#       pathType: Prefix
#       backend:
#         service:
#           name: admin-service
#           port:
#             number: 8080

# ServiceAccount configuration
serviceAccount:
  enabled: true
  name: ""
  annotations: {}
  labels: {}
  automountServiceAccountToken: true

# RBAC configuration
rbac:
  enabled: false
  # Use Role or ClusterRole
  type: Role
  rules: []
  # - apiGroups: [""]
  #   resources: ["pods"]
  #   verbs: ["get", "list", "watch"]
  aggregationRule: {}
  # clusterRoleSelectors:
  # - matchLabels:
  #     rbac.example.com/aggregate-to-monitoring: "true"
  labels: {}
  annotations: {}
  # Custom roleRef name (defaults to release fullname)
  roleRef: ""
  # Custom subjects (defaults to service account)
  subjects: []
  # - kind: ServiceAccount
  #   name: custom-sa
  #   namespace: default
  # - kind: User
  #   name: jane
  #   apiGroup: rbac.authorization.k8s.io

  # Extra roles and bindings
  extraRoles: {}
  # reader:
  #   enabled: true
  #   type: Role  # or ClusterRole
  #   createBinding: true
  #   rules:
  #   - apiGroups: [""]
  #     resources: ["pods", "services"]
  #     verbs: ["get", "list", "watch"]
  # aggregated:
  #   enabled: true
  #   type: ClusterRole
  #   createBinding: false  # Just create the role for aggregation
  #   labels:
  #     rbac.example.com/aggregate-to-monitoring: "true"
  #   rules:
  #   - apiGroups: [""]
  #     resources: ["pods/metrics"]
  #     verbs: ["get", "list"]

# ConfigMap configuration
configMap:
  enabled: false
  data: {}
  binaryData: {}
  annotations: {}
  labels: {}
  envFrom: false
  mountPath: ""
  subPath: ""

# Secret configuration
secret:
  enabled: false
  type: Opaque
  data: {}
  stringData: {}
  annotations: {}
  labels: {}
  envFrom: false
  mountPath: ""
  subPath: ""

# Extra ConfigMaps
extraConfigMaps: {}
# my-config:
#   data:
#     config.yaml: |
#       key: value
#   mountPath: /config
#   envFrom: true

# Extra Secrets
extraSecrets: {}
# my-secret:
#   stringData:
#     api-key: "secret-value"
#   mountPath: /secrets
#   envFrom: true

# Persistence configuration
persistence:
  enabled: false
  # For simple single PVC (backward compatibility)
  accessMode: ReadWriteOnce
  size: 8Gi
  storageClass: ""
  volumeMode: Filesystem
  mountPath: /data
  subPath: ""
  annotations: {}
  labels: {}
  selector: {}
  dataSource: {}

  # Multiple PVCs
  volumes: {}
  # data:
  #   enabled: true
  #   accessMode: ReadWriteOnce
  #   size: 10Gi
  #   storageClass: fast-ssd
  #   mountPath: /data
  # cache:
  #   enabled: true
  #   accessMode: ReadWriteOnce
  #   size: 5Gi
  #   mountPath: /cache

# EmptyDir volumes
emptyDirVolumes: {}
# temp:
#   medium: Memory
#   sizeLimit: 1Gi
#   mountPath: /tmp
# nginx-cache:
#   mountPath: /var/cache/nginx
#   sizeLimit: 100Mi
# nginx-run:
#   mountPath: /var/run
#   sizeLimit: 10Mi
# nginx-pid:
#   mountPath: /tmp
#   sizeLimit: 10Mi
# Example: In-memory cache for better performance
# app-cache:
#   medium: Memory  # Uses RAM instead of disk
#   sizeLimit: 256Mi
#   mountPath: /app/cache

# HostPath volumes (use with caution)
hostPathVolumes: {}
# logs:
#   path: /var/log
#   type: Directory
#   mountPath: /host/logs
#   readOnly: true

# Extra volumes
extraVolumes: []
# - name: config-volume
#   configMap:
#     name: my-config

# Extra volume mounts
extraVolumeMounts: []
# - name: config-volume
#   mountPath: /config

# Host aliases
hostAliases: []
# - ip: "127.0.0.1"
#   hostnames:
#   - "foo.local"
#   - "bar.local"

# Horizontal Pod Autoscaler
hpa:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 80
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior: {}

# Vertical Pod Autoscaler
vpa:
  enabled: false
  updateMode: Auto  # Off, Initial, Recreate, Auto
  labels: {}
  annotations: {}
  # Update policy
  updatePolicy: {}
  # updateMode: Auto
  # minReplicas: 1

  # Container policies
  containerPolicies: []
  # - containerName: "*"  # or specific container name
  #   mode: Auto  # Off, Auto
  #   minAllowed:
  #     cpu: 100m
  #     memory: 128Mi
  #   maxAllowed:
  #     cpu: 2
  #     memory: 4Gi
  #   controlledResources: ["cpu", "memory"]
  #   controlledValues: RequestsAndLimits  # RequestsOnly, RequestsAndLimits

  # Full resource policy (alternative to containerPolicies)
  resourcePolicy: {}

  # Custom recommenders
  recommenders: []
  # - name: custom-recommender

# Pod Disruption Budget
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1
  unhealthyPodEvictionPolicy: ""

# Network Policy
networkPolicy:
  enabled: false
  policyTypes:
  - Ingress
  - Egress
  ingress: []
  # - from:
  #   - podSelector:
  #       matchLabels:
  #         role: frontend
  #   ports:
  #   - protocol: TCP
  #     port: 80
  egress: []
  # - to:
  #   - podSelector:
  #       matchLabels:
  #         role: database
  #   ports:
  #   - protocol: TCP
  #     port: 5432

# Gateway API configuration (for applications)
# Note: GatewayClass and Gateway resources should be managed by platform teams
gateway:
  # HTTPRoute configuration
  httpRoute:
    enabled: false
    labels: {}
    annotations: {}
    # Parent Gateway references (references existing gateways managed by platform team)
    parentRefs: []
    # - name: example-gateway
    #   namespace: gateway-system
    #   sectionName: https
    #   port: 443

    # Hostnames for routing
    hostnames: []
    # - "example.com"
    # - "*.example.com"

    # HTTP routing rules
    rules: []
    # - matches:
    #   - path:
    #       type: PathPrefix
    #       value: /api
    #     headers:
    #     - type: Exact
    #       name: x-version
    #       value: v1
    #     queryParams:
    #     - type: Exact
    #       name: env
    #       value: prod
    #     method: GET
    #   filters:
    #   - type: RequestHeaderModifier
    #     requestHeaderModifier:
    #       set:
    #       - name: x-forwarded-proto
    #         value: https
    #       add:
    #       - name: x-custom-header
    #         value: custom-value
    #       remove:
    #       - x-debug
    #   - type: ResponseHeaderModifier
    #     responseHeaderModifier:
    #       set:
    #       - name: cache-control
    #         value: no-cache
    #   - type: RequestRedirect
    #     requestRedirect:
    #       scheme: https
    #       hostname: secure.example.com
    #       path:
    #         type: ReplaceFullPath
    #         replaceFullPath: /secure/api
    #       port: 443
    #       statusCode: 301
    #   - type: URLRewrite
    #     urlRewrite:
    #       hostname: backend.example.com
    #       path:
    #         type: ReplacePrefixMatch
    #         replacePrefixMatch: /v1/api
    #   - type: RequestMirror
    #     requestMirror:
    #       backendRef:
    #         name: mirror-service
    #         port: 80
    #   backendRefs:
    #   - name: api-service
    #     port: 8080
    #     weight: 90
    #   - name: api-service-v2
    #     port: 8080
    #     weight: 10
    # - matches:
    #   - path:
    #       type: PathPrefix
    #       value: /
    #   backendRefs:
    #   - name: web-service
    #     port: 80

    # Extra HTTPRoutes
    extraRoutes: {}
    # api:
    #   enabled: true
    #   parentRefs:
    #   - name: api-gateway
    #   hostnames:
    #   - api.example.com
    #   rules:
    #   - matches:
    #     - path:
    #         type: PathPrefix
    #         value: /v1
    #     backendRefs:
    #     - name: api-v1-service
    #       port: 8080

  # TCPRoute configuration
  tcpRoute:
    enabled: false
    labels: {}
    annotations: {}
    # Parent Gateway references (references existing gateways managed by platform team)
    parentRefs: []
    # - name: tcp-gateway
    #   namespace: gateway-system
    #   sectionName: tcp
    #   port: 9000

    # TCP routing rules
    rules: []
    # - backendRefs:
    #   - name: tcp-service
    #     port: 9000
    #     weight: 100
    # - backendRefs:
    #   - name: database-service
    #     port: 5432
    #     weight: 90
    #   - name: database-replica
    #     port: 5432
    #     weight: 10

    # Extra TCPRoutes
    extraRoutes: {}
    # database:
    #   enabled: true
    #   parentRefs:
    #   - name: database-gateway
    #   rules:
    #   - backendRefs:
    #     - name: postgres-primary
    #       port: 5432
    #       weight: 70
    #     - name: postgres-replica
    #       port: 5432
    #       weight: 30

  # ReferenceGrant for cross-namespace access
  referenceGrant:
    enabled: false
    labels: {}
    annotations: {}

    # Allow access from these resources
    from: []
    # - group: gateway.networking.k8s.io
    #   kind: Gateway
    #   namespace: gateway-system
    # - group: gateway.networking.k8s.io
    #   kind: HTTPRoute
    #   namespace: app-routes

    # Allow access to these resources
    to: []
    # - group: ""
    #   kind: Service
    #   name: backend-service
    # - group: ""
    #   kind: Secret
    #   name: tls-cert

    # Extra ReferenceGrants
    extraGrants: {}
    # secrets:
    #   enabled: true
    #   from:
    #   - group: gateway.networking.k8s.io
    #     kind: Gateway
    #     namespace: gateway-system
    #   to:
    #   - group: ""
    #     kind: Secret

# CronJobs configuration (key is cronjob name suffix)
cronjobs: {}
# backup:
#   enabled: true
#   schedule: "0 2 * * *"
#   concurrencyPolicy: Forbid
#   successfulJobsHistoryLimit: 3
#   failedJobsHistoryLimit: 1
#   startingDeadlineSeconds: 200
#   image:
#     repository: myapp
#     tag: backup-1.0.0
#   command: ["/bin/sh"]
#   args: ["-c", "backup.sh"]
#   resources:
#     requests:
#       cpu: 100m
#       memory: 128Mi
#   # Schedule on nodes with local storage for faster backups
#   nodeSelector:
#     storage-type: local-ssd
#   tolerations:
#     - key: dedicated
#       operator: Equal
#       value: backup
#       effect: NoSchedule

# Jobs configuration (key is job name suffix)
jobs: {}
# migration:
#   enabled: true
#   backoffLimit: 6
#   completions: 1
#   parallelism: 1
#   ttlSecondsAfterFinished: 300
#   restartPolicy: OnFailure
#   image:
#     repository: myapp
#     tag: migration-1.0.0
#   command: ["/bin/sh"]
#   args: ["-c", "migrate.sh"]
#   resources:
#     requests:
#       cpu: 100m
#       memory: 256Mi
#   # Ensure migration runs on same zone as database
#   affinity:
#     nodeAffinity:
#       requiredDuringSchedulingIgnoredDuringExecution:
#         nodeSelectorTerms:
#           - matchExpressions:
#               - key: topology.kubernetes.io/zone
#                 operator: In
#                 values:
#                   - us-east-1a  # Same zone as primary database

# Helm hooks for lifecycle management
hooks:
  enabled: false

  # Pre-install hooks (run before any resources are created)
  preInstall: []
  # - name: db-migration
  #   image: migrate/migrate:latest
  #   command:
  #   - migrate
  #   args:
  #   - -path=/migrations
  #   - -database=postgres://user:pass@db:5432/mydb?sslmode=disable
  #   - up
  #   weight: 1
  #   deletePolicy: before-hook-creation
  #   ttlSecondsAfterFinished: 300
  #   restartPolicy: Never
  #   env:
  #   - name: DB_HOST
  #     value: postgres-service
  #   resources:
  #     limits:
  #       memory: "256Mi"
  #     requests:
  #       cpu: "100m"
  #       memory: "128Mi"

  # Post-install hooks (run after all resources are created and ready)
  postInstall: []
  # - name: data-seed
  #   image: curlimages/curl:latest
  #   command:
  #   - sh
  #   - -c
  #   - |
  #     curl -X POST http://release-name/api/seed \
  #       -H "Content-Type: application/json" \
  #       -d '{"action": "seed_initial_data"}'
  #   weight: 1
  #   deletePolicy: hook-succeeded
  #   ttlSecondsAfterFinished: 600
  #   restartPolicy: Never

  # Pre-upgrade hooks (run before upgrade starts)
  preUpgrade: []
  # - name: backup-db
  #   image: postgres:13-alpine
  #   command:
  #   - pg_dump
  #   args:
  #   - -h
  #   - postgres-service
  #   - -U
  #   - postgres
  #   - mydb
  #   - -f
  #   - /backup/pre-upgrade-$(date +%Y%m%d-%H%M%S).sql
  #   weight: 1
  #   deletePolicy: before-hook-creation
  #   ttlSecondsAfterFinished: 3600
  #   restartPolicy: Never
  #   volumeMounts:
  #   - name: backup-storage
  #     mountPath: /backup

  # Post-upgrade hooks (run after upgrade completes)
  postUpgrade: []
  # - name: verify-migration
  #   image: migrate/migrate:latest
  #   command:
  #   - migrate
  #   args:
  #   - -path=/migrations
  #   - -database=postgres://user:pass@db:5432/mydb?sslmode=disable
  #   - version
  #   weight: 1
  #   deletePolicy: hook-succeeded
  #   ttlSecondsAfterFinished: 300
  #   restartPolicy: Never

  # Pre-delete hooks (run before any resources are deleted)
  preDelete: []
  # - name: data-export
  #   image: postgres:13-alpine
  #   command:
  #   - pg_dump
  #   args:
  #   - -h
  #   - postgres-service
  #   - -U
  #   - postgres
  #   - mydb
  #   - -f
  #   - /backup/final-backup-$(date +%Y%m%d-%H%M%S).sql
  #   weight: 1
  #   deletePolicy: hook-succeeded
  #   ttlSecondsAfterFinished: 3600
  #   restartPolicy: Never

  # Post-delete hooks (run after all resources are deleted)
  postDelete: []
  # - name: cleanup-external
  #   image: curlimages/curl:latest
  #   command:
  #   - sh
  #   - -c
  #   - |
  #     curl -X DELETE http://external-service/api/cleanup \
  #       -H "Authorization: Bearer $API_TOKEN"
  #   weight: 1
  #   deletePolicy: hook-succeeded
  #   ttlSecondsAfterFinished: 300
  #   restartPolicy: Never

# External Secrets Operator integration
# Allows pulling secrets from external secret management systems
# Note: The chart automatically detects and uses the latest available API version:
# - v1 (preferred if available)
# - v1beta1 (fallback for older installations)
externalSecrets: {}
  # aws-secrets:
  #   enabled: true
  #   refreshInterval: 1h
  #   secretStoreRef:
  #     name: aws-secretsmanager
  #     kind: ClusterSecretStore
  #
  #   target:
  #     name: aws-app-secrets
  #     creationPolicy: Owner
  #
  #   # Pull from AWS Secrets Manager
  #   data:
  #     - secretKey: api-key
  #       remoteRef:
  #         key: prod/api/external-service
  #         property: api_key
  #     - secretKey: client-secret
  #       remoteRef:
  #         key: prod/api/external-service
  #         property: client_secret
  #
  #   # Pull entire secret as JSON
  #   dataFrom:
  #     - extract:
  #         key: prod/api/config
  #
  #   # Use all keys from the created secret as environment variables
  #   envFrom: true
  #   # Optional: prefix all env vars from this secret
  #   prefix: AWS_

# AWS Target Group Binding (for AWS Load Balancer Controller)
targetGroupBinding:
  enabled: false
  labels: {}
  annotations: {}
  # Target Group ARN from AWS
  targetGroupARN: ""
  # Service reference
  serviceRef:
    # Service name (defaults to release name)
    name: ""
    # Service port name or number
    port: "http"
  # Target type: instance (default) or ip
  targetType: ""
  # IP address type: ipv4 (default) or dualstack
  ipAddressType: ""
  # Networking configuration
  networking: {}
  # ingress:
  # - from:
  #   - securityGroup:
  #       groupID: sg-123456
  #   ports:
  #   - protocol: TCP
  #     port: 80

# Extra Target Group Bindings
extraTargetGroupBindings: {}
# grpc-service:
#   enabled: true
#   targetGroupARN: arn:aws:elasticloadbalancing:region:account:targetgroup/grpc-tg/1234567890
#   serviceRef:
#     name: my-grpc-service
#     port: 50051
#   targetType: ip

# Extra Kubernetes objects
extraObjects: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: "{{ .Values.generic.branchName }}-extra-cm"  # Template example
#   data:
#     branch: "{{ .Values.generic.branchName }}"         # Template example
#     key: value
